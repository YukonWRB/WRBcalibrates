<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Ghislain de Laplante" />

<meta name="date" content="2023-05-10" />

<title>WRBcalibrates Shiny App User Guide</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>







<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">WRBcalibrates Shiny App User Guide</h1>
<h4 class="author">Ghislain de Laplante</h4>
<h4 class="date">2023-05-10</h4>



<p>Important note regarding this vignette: if you are reading this in an
HTML, Word or PDF document from the package folder on the G drive and
wish to update the document, please do so via the vignette R Markdown
document and re-publish/overwrite the document. The R Markdown document
should be the ultimate source of truth regarding this R package and
associated Shiny application. Instructions on how to do so are provided
in the vignette Markdown document.</p>
<p>This vignette may also come to contain R code and links to other
documentation. For best performance and to ensure that all links
function, it is recommended to view this vignette from within R Studio.
You can view all package vignettes with ‘vignette(package =
“WRBcalibrates”)’ or this particular vignette with ‘vignette(topic =
“WRBcalibrates_guide”)’. Note however that vignettes may not have been
installed, depending on the method you used to install the package.</p>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>The Water Resources Branch has a long and stellar history of
deploying and using field instruments, but a less than excellent
record-keeping methodology. Consequently, many historical field
measurements dependent on accurate sensor readings are questionable at
best, unusable at worst. To remedy this problem, new protocols call for
regular calibrations or cross-checking of instruments where measurements
are not corrected by field readings (e.g. water levels). Calibration
records can then be used to a) validate field readings, and b) to apply
corrections or offsets to field measurements, for example by shifting
temperatures to account for linear sensor drift.</p>
<p>A first attempt at an application that could facilitate this
record-keeping and, especially, facilitate future use of said data was
done by CBTS in winter 2021. Unfortunately, due to poor software
selection, staffing changes, and de-prioritization, this app was never
fully operational. To avoid having another field season with only sparse
paper records, a decision to create an in-house app was made in spring
2023, yielding an R Shiny application with much more flexibility and
suitability for the task than the original Survey123 application.</p>
<p>The Shiny application is built within an R package, the intent of
which is to facilitate the collection and storage instrument and
calibration data, ensure safe storage, and facilitate future use of
collected data. The calibrations app itself is deployed on the web at <a href="https://YukonWRB/shinyapps.io/WRBcalibrates/" class="uri">https://YukonWRB/shinyapps.io/WRBcalibrates/</a> as of
2023-05-08 and interacts with Google sheets for data storage. The
strengths and limitations of this system is discussed below, as are
future improvements to app and data storage schemes.</p>
</div>
<div id="the-wrbcalibrates-package-at-a-glance" class="section level1">
<h1>The WRBcalibrates package at a glance</h1>
<p>The WRBcalibrates package is viewable at the private GitHub
repository <a href="https://github.com/YukonWRB/WRBcalibrates">YukonWRB/WRBcalibrates
(github.com)</a>. The repository should be viewable by members of the
YukonWRB organization, and is built with a typical R package structure.
The primary functions within this package are:</p>
<ul>
<li><p>app_server() defines the server side of the Shiny app.</p></li>
<li><p>app_ui() defines the user interface of the Shiny app.</p></li>
<li><p>run_app() starts the Shiny application</p></li>
<li><p>db_create() create an SQL-type database compliant with what is
expected by the app.</p></li>
<li><p>calConnect() creates a connection to the SQL-type database. This
function is used within app_server, but should be referenced whenever
connection to the calibrations database is necessary. Future changes to
the database type or location can then be passed to a single function
instead of having to find each connection.</p></li>
</ul>
<p>This package contains additional functions and capabilities, but
these are beyond the scope of this vignette. Please consult the
individual function help files or consult with the package developer for
more information.</p>
</div>
<div id="running-and-updating-the-shiny-app" class="section level1">
<h1>Running and updating the Shiny app</h1>
<p>You can run the app locally or access a deployed instance at
shinyapps.io. Careful though: at this time, there is no provision to
make Google Sheets and the local database congruent; it’s one option or
the other. Even though you could run the app locally and modify the code
to work with a local database, those records would not be automatically
sent to the Google Sheets data store and vice-versa. See section Future
improvements for more details.</p>
<div id="local-instances" class="section level2">
<h2>Local instances</h2>
<div id="running-the-shiny-app" class="section level3">
<h3>Running the Shiny app</h3>
<p>Use the function run_app() from either the installed package or the
package loaded by devtools::load_all(). Note that app_server() as a
hard-coded parameter that controls usage of the Google Sheets storage or
a local database: to use the local database, set use_database to TRUE at
line 9.</p>
</div>
<div id="updating-the-shiny-app" class="section level3">
<h3>Updating the Shiny app</h3>
<p>Updating the Shiny app code locally is simple: install the latest
version of the package prior to calling function run_app(). Stable
versions of the package are located on the G drive here and can be
installed using function remotes::install_local(path_to_tar.gz file), or
you can install the latest and (hopefully) greatest version from GitHub
using function remotes::install_github(YukonWRB/WRBcalibrates)</p>
</div>
</div>
<div id="web-deployed-instances" class="section level2">
<h2>Web-deployed instances</h2>
<div id="running-the-shiny-app-1" class="section level3">
<h3>Running the Shiny app</h3>
<p>The app is published to shinyapps.io as of May 2023 and is accessible
at <a href="https://YukonWRB.shinyapps.io/WRBcalibrates/" class="uri">https://YukonWRB.shinyapps.io/WRBcalibrates/</a>.</p>
</div>
<div id="updating-the-shiny-app-1" class="section level3">
<h3>Updating the Shiny app</h3>
<p>Updating the deployed app is done from RStudio, and you must have the
package repository loaded as a project in RStudio and synchronized to
GitHub.</p>
<p>IMPORTANT: If this is the first time you run the app on your machine
and you are using Google Sheets, you’ll have to tweak the app_server.R
code a bit and run the app locally first to set up a secret password
allowing the connection to Google Sheets. Specifically:</p>
<ol style="list-style-type: decimal">
<li>Find the first big <em>if</em> loop containing commented code about
authenticating from Google (at line 42 as of May 10, 2023).</li>
<li>Uncomment and run the lines calling function
googlesheets4::gs4_auth() and , if needed,
googledrive::drive_auth().</li>
<li>Call devtools::load_all(), then run the app with run_app().</li>
<li>The app will start, and so should a browser window asking you to
confirm which email to use with google sheets. This email should be <a href="mailto:wrbcalibrates@gmail.com">wrbcalibrates@gmail.com</a>, and
the credentials are listed in the section of this document called
“Passwords and logins”.</li>
<li>The app should then load data; confirm that this worked by looking
for instrument numbers in calibration basic data, managing instruments
and sensors, or anywhere else that renders data pulled from Google.</li>
<li>Re-comment the two authentication lines that you ran in Step 2.</li>
<li>Call devtools::load_all() again to load these last changes.</li>
</ol>
<p>Once these steps are done, or to re-publish the app from a computer
already holding the google secret codes, publish the app by following
these steps:</p>
<ol style="list-style-type: decimal">
<li>Call up the app with run_app().</li>
<li>In the local instance of the app that pops up, find the “Publish” or
“Republish” button at the top right.</li>
<li>Publish/republish the app. You can unclick many of the
files/folders: anything starting with dev/, the /man and /test folders,
as well as the README files. Everything else is necessary.</li>
</ol>
</div>
</div>
</div>
<div id="data-storage" class="section level1">
<h1>Data storage</h1>
<p>For simplicity and rapid deployment outside of YG wired networks, the
app was initially deployed with a Google Sheets back-end. This isn’t
ideal, as it’s impossible to pass SQL statements like “UPDATE table SET
column = value WHERE condition”: instead, a specific row or cell must be
targeted. To mitigate the risk of conflicts where two users are using
the application at the same time, each sheet is read immediately prior
to modifying cell/row contents, which slows down the app considerably.
SQL statements can avoid this issue with the WHERE clause, which can
along with the SET statement can target a specific cell.</p>
<p>The application is already set up to work with an SQL database
however; all that’s missing is a database to work with, and a
modification to line 9 of the app_server.R file. Using an SQL-type
database should be implemented as soon as practicable, as this would
allow automatic backup, prevent potential authentication issues to
Google, and drastically speed up the application.</p>
<div id="sql-database-setup" class="section level2">
<h2>SQL database setup</h2>
<p>As mentioned previously, there is a function already made to create
an SQLite database and its schema as part of the package: db_create().
With a modification to the initial database connection code, this code
could create tables in any database type that understands SQL language.
That said, the function can create an SQLite database from scratch,
which isn’t possible with server-type databases. For databases like
PostgreSQL, Microsoft SQL Server, or other types, the database should
first be initialized outside of R without any tables; once that’s done,
modify the function to connect to the database and run the dbExecute()
statements to create tables and establish relationships.</p>
<p>If you opt to work with a database type other than SQLite or if the
path to the database changes from the default G drive path, you must
remember to update the calConnect() function. It is currently set up to
connect to an SQLite database on the G/Common_GW_SW folder, which will
no longer be appropriate.</p>
</div>
</div>
<div id="future-improvements" class="section level1">
<h1>Future improvements</h1>
<p>Besides the migration of data storage from Google Sheets to an
SQL-type database, the following improvements could be considered:</p>
<ul>
<li><p>There are a handful of instances where a table is re-read from
the remote data store without being strictly necessary: it is possible
to simply modify the tables stored in reactiveValues (in the R
environment) to mirror the changes pushed to the remote store.</p></li>
<li><p>Adding a user-interface component that permits viewing
calibration entries. It’s a bit tricky to sort out how best to serve
this information to the user, and with the Google Sheets back-end, how
to do so quickly. Calibrations are spread out across 8 different tables:
one for the basic observation information (observer, instrument, time,
etc) and 7 for the individual parameters. An end-user might be looking
for all calibrations on a certain day or all calibrations with a certain
instrument (both of which entails searching each table) or might be
looking for calibrations of a certain parameters (two tables; the basic
observation, and the parameter table). Careful selection of the filters
visible to the user is necessary.</p></li>
<li><p>The app could/should be deployed on a Linux machine using Shiny
Server, as is done by the Yukon Geological Survey with their permafrost
database. This solution bypasses the cost or hour limitations of
shinyapps.io and permits us to use an SQL database without finding a
suitable cloud database.</p></li>
<li><p>The instruments table is inefficient in how it stores instrument
types. Every entry is long and repeated, such as “Logger
(single/multi-param deployable, fixed sensors)” instead, this could be a
number that is referenced in another table. This would require changes
to the server and ui codes as well as addition of a table with
appropriate keys.</p></li>
</ul>
</div>
<div id="passwords-and-logins" class="section level1">
<h1>Passwords and logins</h1>
<p>For security reasons (as this package is maintained on GitHub), the
passwords used to access Shinyapps.io and the Google Drive which can be
used with this package are located in <a href="%22G:\water\Common_GW_SW\R-packages\WRBcalibrates\Shiny%20app%20secrets.txt%22">this
document</a>.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
